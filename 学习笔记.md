# TypeScript 学习笔记

类型是普遍存在的，每一个值都有一个对应的类型，无论这个值是普通对象，还是数组，还是函数，还是类，等等，都会有一个类型。

## 目录

- [类型和值](#类型与值)
    - [有标识符的类型或值](#有标识符的类型或值)
    - [要构造的类型或值](#要构造的类型或值)
- [类型断言](#类型断言)
- [类型检查的时机](#类型检查的时机)
- [接口](#接口)
    - [接口描述对象类型](#接口描述对象类型)
    - [接口描述数组类型](#接口描述数组类型)
    - [接口描述函数类型](#接口描述函数类型)
    - [接口描述类的类型](#接口描述类的类型)

## 类型与值

### 有标识符的类型或值

- 仅为基本类型的标识符

    `boolean`, `number`, `string`, `bigint`, `symbol`

- 既为基本类型又为值的标识符

    `undefined`, `null`

- 仅为复合类型的标识符

    - `void`：指 `undefined` 或 `null`
    - `object`：除基本类型的其他类型，其实也就是广义上的对象
    - `any`：指任意类型
    - `never`：没有类型。一般用在函数的返回值上，说明这个函数不会执行完，无法返回值，那自然这个函数返回的类型就是没有类型了。

### 要构造的类型或值

这种类型没有专门的标识符，但是可以用语法构造出来。

复杂类型的重点在于这一类型的值结构一致。基本类型和复合类型则是指值的范围一致。所以类型包括值的集合和结构两种。

- 仅为复杂类型

    - 数组：*itemType*[]
    - 元组：[type0, type1, type2, ..., typeN]，里面每个 `type` 都是已知的，与数组的区别就是不用每个元素类型相同（虽然 any[] 也有这种效果，但是元组里面的元素都是明确类型的，而不是随便什么类型），且元素个数是固定的，数组可以是无限个元素。**但是元组本质上还是个数组，因为此类型对应的值是数组。**
    - 对象：`{ a: string, b: number }`，这都是符合某种结构的类型。
    - 函数：`(a: string, b: number) => string` 或者 `{ (a: number): string }`
    - 只读数组：`ReadonlyArray<type>`，意味着数组不能使用涉及到修改原数组的方法，比如 `splice`、`pop`，也不能赋值

- 既为简单类型又为值

    - 特定字符串类型：`'string'`，直接一个字符串就代表了一种类型
    - 特定数字类型：`number`，直接一个数字就代表了一种类型
    - 特定枚举成员类型：枚举成员是字面量初始化时代表了一种类型

- 既为复杂类型又为值

    - 枚举： `enum`，枚举既是类型，又是值，可以使用，枚举类型的值在 `JS` 中是个对象，这个对象的键是枚举的所有属性和值，值是属性对应的值或者值对应的属性，互通的。

**部分类型可以用接口来描述。接口定义时产生的标识符也可作为类型使用。**

## 类型断言

语法是 `(value as type)`，明确声明值的类型。

## 类型检查的时机

当定义完类型后，会不会生效或报错取决于类型检查的时机，一般来说，类型检查发生在使用类型对应的变量的时候，通常变量赋值时是会检查的。如果此变量是函数，那么调用的时候检查，如果变量是类，那么 `new Class` 时会检查实例的方法和属性。

## 接口

接口是一种对复合类型“结构化描述”的方式，同时，接口定义时产生的标识符也可以作为那种复合类型的类型标识符来使用，也就是说那个标识符也可以代表一个类型了。

接口是支持多继承的。

接口还能从类继承，这时候把类看成是个隐性的接口，不管是私有还是公共属性，其类型的法则都会被接口给拿过来。

### 接口描述对象类型

```ts
interface User {
    name: string;
    readonly age: number;
    weight?: number;
    // 字符串索引签名，propName 可以随意
    // 字符串索引的值类型要比 name, age, weight 类型加起来范围要广，否则会报错的
    [propName: string]: any;
    // 同上
    [x: string]: any;
    // 数值索引签名，同上，对象里面的数值键会转为字符串
    [y: number]: any;
}
```

- 只读属性，`readonly` 修饰，意味着对象在首次赋值给变量后，变量的属性不能更改
- 字符串/数值索引签名，表示确实还有其他属性，如果没有，那么就不应该用这个。

### 接口描述数组类型

```ts
interface ArrayType {
    [x: index]: string;
}
```

**只读数组类型只能用接口来描述：**

```ts
interface ReadonlyArrayType {
    readonly [x: index]: string;
}
```

### 接口描述函数类型

这个接口又叫 “调用签名”。这种接口每一对属性和值都代表函数的一种输入输出情况，多对也就代表函数可以有多中输入输出情况。

```ts
// 符合这个类型的函数，传 (number, string) 会得到 boolean，传 (number, number) 会得到 string，当然，一般函数不会定义成这个样子
interface FunctionType {
    // 属性是参数列表的类型，值是返回值的类型
    (arg0: number, arg1: string): boolean;
    (arg0: number, arg1: number): string;
}
```

### 接口描述类的类型

类的类型主要是说这个类有哪些 `public` 的属性和方法，不包括私有属性和方法。这里有几点要注意的：

- `implements` 的 `type` 表示的是在用类生成实例时执行类型检查，所以不会检查静态方法
- 类的构造函数（静态方法）类型检查需要借助另一个函数调用时的参数检查或变量赋值时的检查来达到目的

构造函数的接口描述：

```ts
interface X {
    // 前面有个 new 哦
    new (a: string, b: string): string;
}
```

### 接口描述多种类型

这个很简单，只要把上面的描述不同类型的方法在一个接口里面混合使用就好了，这种混合使用意味着变量是多种类型中的任意一种。

## 类

- 如果两个类所有成员类型都相同，且都是 `public` 的成员，那么一个类型的值可以赋给另一个类型的变量。（兼容法则）
- `protected` 成员不能在实例中访问，只能在类内部或子类通过 `this` 访问。`private` 则只能在类内部访问。
- 当类的构造函数使用 `protected` 修饰符时，说明这个类不能被实例化，只能被继承。
- `abstract` 声明的抽象类不能被实例化，只能被继承，`abstract` 声明的成员函数仅仅是个类型声明，不能实现，得在子类去实现。
- `readonly` 的属性只能声明时初始化或者在构造函数中赋值。
- 如果构造函数的参数使用了访问修饰符，即 `public`, `private`, `protected`，那么该参数名会作为类的成员名。
- 类和对象一样，可以设置 `getter`, `setter`
- `static` 的成员在类上不在实例上
- 类的标识符实际上代表类的实例的类型，也就是 `this` 的类型，`typeof ClassName` 代表的是 `ClassName` 函数（结合类在 ES5 中的实现想想）本身的类型。

## 函数

- 当一个函数根据不同参数返回不同值的时候，除了接口描述，还可以使用 **函数重载** 支持这种类型声明，即在函数上方写几个相同的函数声明，只写类型部分，不写函数体。

## 泛型

- 泛型存在的目的是为了明确函数参数类型和返回类型是相同的，但至于是什么类型，这个随意。这一点是 `any` 所不能表达的
- 泛型是指函数，并不是指类型，泛型的全称应该是叫泛型函数
- 泛型函数中在 `(参数...)` 前面的 `<>` 内所写的符号叫做 “类型变量”，因为它表现的就很像一个变量，即调用函数时通过传参才知道这个变量代表的类型

- 泛型函数、泛型接口、泛型类
- 类型变量可以继承接口，从而给类型变量附加了一些条件，即不再是任意值，而是**至少**满足接口条件的值
- 类型变量也可以继承于另一个类型变量
- 泛型约束的是调用时参数的类型，类的静态属性不属于这一类

## 枚举

- 枚举是可以做一些简单的计算的，这些计算在编译器生成 `JS` 时就会算出来并放在原来的位置

<未完待续> TODO:

## 高级类型

- `type0 & type1`，交叉类型，即这种类型的值拥有每个类型的特性，比如一个类有其他两个类都有的成员，那么这个类的类型就能写成这样
    - 交叉类型和继承有点像，不过交叉类型可以合并继承描述不了的类型
- `type0 | type1`，联合类型，即这种类型的值只能是其中一种类型，如果这个值要使用某个类型的全部特性，则需要根据条件判断（可能需要配合*类型谓词*）或者**类型断言**来使用，否则只能访问所有类型共有的特性。这种保证值能使用某类型的特性的做法叫做*类型守卫*，经常使用 `in`, `instanceOf`, `typeof`, 某函数返回值加上谓词短语等等。断言也可以，`value!` 也是一种断言，意味着 `value` 不是 `undefined` 或 `null` 类型。

### 类型别名

`type` 关键字是给之前讨论的各种类型取个其他的名字，也就是说 `type` 可以引用各种类型。比 `interface` 仅描述几种类型强大的多。

**当鼠标移至变量上的时候，提示变量的类型时，如果是接口实现的类型会显示接口类型名，因为接口是真的创建了一个类型的，如果是类型别名则会显示类型别名指向的真正类型，因为类型别名只是传引用，没有实现真正的类型。所以，尽可能用接口，而不要用类型别名，否则提示的时候出现一大堆的类型细节，那就非常难理解了，接口做到了真正的抽象，类型别名相当于复制粘贴，只是让你写起来少写了一些字。**

**使用类型别名前先思考下有没有更抽象的方案。**

### 其他类型

- `this` 类型，类里面可以使用 `this` 来代指实例的类型
- `keyof T` 的类型是 `T` 上所有已知属性的联名类型
- `T[K]` 类型则是 `T` 中属性为 `K` 的类型，即所有已知属性的值的联名类型，TODO: 映射类型
- `<type condition> ? type0 : type1`，有条件类型，符合前面的条件，就是 `type0`，不符合就是 `type1`，可能复合也可能不符合就是 `typ0 | type1`，没有足够条件判断就是此表达式。

### 其他

- `[K in T]` 会把 `T` 中的每个类型都放到对象类型里面。
- ``

## 模块

```ts
const something
// 是下面这样，相当于 export const something
export { something }
// 而不是下面这样
// export something
```

如果项目要作为一个 `CommonJS` 或 `AMD` 模块使用，则需要在主文件下用 `export = something` 来导出模块，相当于 `module.exports = something`，当然，`TS` 也有相应的语法导入这种**纯** `CommonJS` 和 `AMD` 模块，即 `import something = require('...')`，不过一般现在一个模块都支持各种模块导入方式了。

### 模块声明文件

模块声明文件是给其他使用这个模块的库用的，用 `.d.ts` 写，语法如下：

```ts
// 声明一个模块，模块名是什么
declare module 'moduleName' {
    // 导出一个什么东西，类型是什么
    export const something: string;
}

// 或者简写，这样导入的模块是 any 类型
declare module 'moduleName';
```

## 命名空间

在一个文件里面，避免全局变量的命名冲突。