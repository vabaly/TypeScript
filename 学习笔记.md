# TypeScript 学习笔记

类型是普遍存在的，每一个值都有一个对应的类型，无论这个值是普通对象，还是数组，还是函数，还是类，等等，都会有一个类型。

## 目录

- [类型和值](#类型与值)
    - [有标识符的类型或值](#有标识符的类型或值)
    - [要构造的类型或值](#要构造的类型或值)
- [类型断言](#类型断言)
- [类型检查的时机](#类型检查的时机)
- [接口](#接口)
    - [接口描述对象类型](#接口描述对象类型)
    - [接口描述数组类型](#接口描述数组类型)
    - [接口描述函数类型](#接口描述函数类型)
    - [接口描述类的类型](#接口描述类的类型)

## 类型与值

### 有标识符的类型或值

- 仅为基本类型的标识符

    `boolean`, `number`, `string`, `bigint`, `symbol`

- 既为基本类型又为值的标识符

    `undefined`, `null`

- 仅为复合类型的标识符

    - `void`：指 `undefined` 或 `null`
    - `object`：除基本类型的其他类型，其实也就是广义上的对象
    - `any`：指任意类型
    - `never`：没有类型。一般用在函数的返回值上，说明这个函数不会执行完，无法返回值，那自然这个函数返回的类型就是没有类型了。

### 要构造的类型或值

这种类型没有专门的标识符，但是可以用语法构造出来。

复杂类型的重点在于这一类型的值结构一致。基本类型和复合类型则是指值的范围一致。所以类型包括值的集合和结构两种。

- 仅为复杂类型

    - 数组：*itemType*[]
    - 元组：[type0, type1, type2, ..., typeN]，里面每个 `type` 都是已知的，与数组的区别就是不用每个元素类型相同（虽然 any[] 也有这种效果，但是元组里面的元素都是明确类型的，而不是随便什么类型），且元素个数是固定的，数组可以是无限个元素。**但是元组本质上还是个数组，因为此类型对应的值是数组。**
    - 对象：`{ a: string, b: number }`，这都是符合某种结构的类型。
    - 函数：`(a: string, b: number) => string` 或者 `{ (a: number): string }`
    - 只读数组：`ReadonlyArray<type>`，意味着数组不能使用涉及到修改原数组的方法，比如 `splice`、`pop`，也不能赋值

- 既为复杂类型又为值

    - 枚举： `enum`，枚举既是类型，又是值，可以使用，枚举类型的值在 `JS` 中是个对象，这个对象的键是枚举的所有属性和值，值是属性对应的值或者值对应的属性，互通的。

**部分类型可以用接口来描述。接口定义时产生的标识符也可作为类型使用。**

## 类型断言

语法是 `(value as type)`，明确声明值的类型。

## 类型检查的时机

当定义完类型后，会不会生效或报错取决于类型检查的时机，一般来说，类型检查发生在使用类型对应的变量的时候，通常变量赋值时是会检查的。如果此变量是函数，那么调用的时候检查，如果变量是类，那么 `new Class` 时会检查实例的方法和属性。

## 接口

接口是一种对复合类型“结构化描述”的方式，同时，接口定义时产生的标识符也可以作为那种复合类型的类型标识符来使用，也就是说那个标识符也可以代表一个类型了。

接口是支持多继承的。

接口还能从类继承，这时候把类看成是个隐性的接口，不管是私有还是公共属性，其类型的法则都会被接口给拿过来。

### 接口描述对象类型

```ts
interface User {
    name: string;
    readonly age: number;
    weight?: number;
    // 字符串索引签名，propName 可以随意
    // 字符串索引的值类型要比 name, age, weight 类型加起来范围要广，否则会报错的
    [propName: string]: any;
    // 同上
    [x: string]: any;
    // 数值索引签名，同上，对象里面的数值键会转为字符串
    [y: number]: any;
}
```

- 只读属性，`readonly` 修饰，意味着对象在首次赋值给变量后，变量的属性不能更改
- 字符串/数值索引签名，表示确实还有其他属性，如果没有，那么就不应该用这个。

### 接口描述数组类型

```ts
interface ArrayType {
    [x: index]: string;
}
```

**只读数组类型只能用接口来描述：**

```ts
interface ReadonlyArrayType {
    readonly [x: index]: string;
}
```

### 接口描述函数类型

这个接口又叫 “调用签名”。这种接口每一对属性和值都代表函数的一种输入输出情况，多对也就代表函数可以有多中输入输出情况。

```ts
// 符合这个类型的函数，传 (number, string) 会得到 boolean，传 (number, number) 会得到 string，当然，一般函数不会定义成这个样子
interface FunctionType {
    // 属性是参数列表的类型，值是返回值的类型
    (arg0: number, arg1: string): boolean;
    (arg0: number, arg1: number): string;
}
```

### 接口描述类的类型

类的类型主要是说这个类有哪些 `public` 的属性和方法，不包括私有属性和方法。这里有几点要注意的：

- `implements` 的 `type` 表示的是在用类生成实例时执行类型检查，所以不会检查静态方法
- 类的构造函数（静态方法）类型检查需要借助另一个函数调用时的参数检查或变量赋值时的检查来达到目的

构造函数的接口描述：

```ts
interface X {
    // 前面有个 new 哦
    new (a: string, b: string): string;
}
```

### 接口描述多种类型

这个很简单，只要把上面的描述不同类型的方法在一个接口里面混合使用就好了，这种混合使用意味着变量是多种类型中的任意一种。

## 类

- 如果两个类所有成员类型都相同，且都是 `public` 的成员，那么一个类型的值可以赋给另一个类型的变量。（兼容法则）
- `protected` 成员不能在实例中访问，只能在类内部或子类通过 `this` 访问。`private` 则只能在类内部访问。
- 当类的构造函数使用 `protected` 修饰符时，说明这个类不能被实例化，只能被继承。
- `abstract` 声明的抽象类不能被实例化，只能被继承，`abstract` 声明的成员函数仅仅是个类型声明，不能实现，得在子类去实现。
- `readonly` 的属性只能声明时初始化或者在构造函数中赋值。
- 如果构造函数的参数使用了访问修饰符，即 `public`, `private`, `protected`，那么该参数名会作为类的成员名。
- 类和对象一样，可以设置 `getter`, `setter`
- `static` 的成员在类上不在实例上
- 类的标识符实际上代表类的实例的类型，也就是 `this` 的类型，`typeof ClassName` 代表的是 `ClassName` 函数（结合类在 ES5 中的实现想想）本身的类型。

## 函数

- 当一个函数根据不同参数返回不同值的时候，除了接口描述，还可以使用 **函数重载** 支持这种类型声明，即在函数上方写几个相同的函数声明，只写类型部分，不写函数体。

## 泛型

- 泛型存在的目的是为了明确函数参数类型和返回类型是相同的，但至于是什么类型，这个随意。这一点是 `any` 所不能表达的
- 泛型是指函数，并不是指类型，泛型的全称应该是叫泛型函数
- 泛型函数中在 `(参数...)` 前面的 `<>` 内所写的符号叫做 “类型变量”，因为它表现的就很像一个变量，即调用函数时通过传参才知道这个变量代表的类型

- 泛型函数、泛型接口、泛型类
- 类型变量可以继承接口，从而给类型变量附加了一些条件，即不再是任意值，而是**至少**满足接口条件的值
- 类型变量也可以继承于另一个类型变量
- 泛型约束的是调用时参数的类型，类的静态属性不属于这一类

## 枚举

- 枚举是可以做一些简单的计算的，这些计算在编译器生成 `JS` 时就会算出来并放在原来的位置

<未完待续> TODO: